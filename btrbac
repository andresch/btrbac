#!/bin/bash

set -e

#
# A small utility to manage incremental backups of a btrfs subvolume
#
# Code follows google coding styleguide (https://github.com/google/styleguide/blob/gh-pages/shell.xml)
#

function usage() {
  echo "
Usage:
  $(basename "$0") -b <backup-dir> -s <subvolume> [options]

  Creates a readonly snapshot of the a btrfs subvolume and archives the changes since the last backup.
  Optionally it uploads the backup to a remote storage via rclone.
  
Mandatory parameters:
  -s <subvolume>:
    Path of the subvolume to backup 
Options 
  -b <backup-dir>:
    Path where to store the backup stream
    If missing, backup archive will not get created
  -x <max-backup-file-size>
    If set the backup stream is split into chunks of the given
    maximal size.
  -p <prefix>
    A prefix that is used for the names of snapshots and backup archives
    If missing the name of the subvolume directory is used
  -n <snapshot-subvolume>
    Path of a subvolume where to place snapshots. The path must be 
    relative to <subvolume> and belong to the same btrfs filesystem. 
    When necessary the subvolume will get created.
    DEFAULT: ".snapshots"
  -c <rclone.conf>
    Path to rclone config files as expected by rclone --config
    If not given, standard default of rclone is used
  -r <rclone-remote>
    The name of a remote location that is configured in the rclone.conf
    If given, this parameter triggers the backup to remote storage
  -f
    Forces a full backup, even if incremental backup would be possible
  -d 
    Enables debug messages
  -h
    This usage information
  --resume[=timestamp]
    Resumes an interrupted backup
  
"
}

function err() {
  local msg="$1"
  echo "${msg}" >&2
  usage >&2
  exit 1
}


while getopts ":s:b:x:c:r:fdn:p:h-:" opt; do
  case $opt in
    s) # path of the subvolume to backup
      readonly SUBVOLUME_PATH="${OPTARG}"
      ;;
    b) # path where to store the backup stream
      BACKUP_ROOT="${OPTARG}"
      ;;
    x) # maximal size of a single backup fragment
      MAX_FILE_SIZE="${OPTARG}"
      ;;
    c) # path to rclone config files
      # rclone tries to replace the rclone.conf file when receiving new auth token.
      # this is not possible when config file is mounted into a docker container
      # In that case we first create a copy and use that
      if [[ -e "/.dockerenv" ]] ; then
        readonly RCLONE_CONFIG_ORIG="${OPTARG}"
        cp "${RCLONE_CONFIG_ORIG}" "/tmp/rclone.conf"
        readonly RCLONE_CONFIG="/tmp/rclone.conf"
      else
        readonly RCLONE_CONFIG="${OPTARG}"
      fi
      ;;
    r) # trigger rclone copy of backup to given rclone remote
      readonly RCLONE_REMOTE="${OPTARG}"
      ;;
    f) # force full backup
      readonly FORCE_FULL_BACKUP=true
      ;;
    d) # enable debug traces
      readonly DEBUG=true
      set -x
      ;;
    n) # how to name the subvolume for the snapshots
      SNAPSHOT_SUBVOL_NAME="${OPTARG}"
      ;;
    p) # prefix for snapshot and backup directories
      PREFIX="${OPTARG}"
      ;;
    h)
      usage
      exit 0
      ;;
    -)
      long_opt_arg="${OPTARG#*=}"
      case "$OPTARG" in
          help) 
            usage
            exit 0
            ;;
          resume=?*) 
            readonly RESUME_TIMESTAMP="${long_opt_arg}"
            readonly MODE="resume"
            ;;
          resume) 
            MODE="resume"
            ;;
          * )       
            err "Invalid option --$OPTARG"
            ;;
      esac
      ;;    
    \?)
      err "Invalid option: -$OPTARG" 
      ;;
    :)
      err "Missing argument for option -$OPTARG."
  esac
done
shift "$((OPTIND-1))"

# ----------------
# Checking required parameters
# ----------------

if [[ ! -d "${SUBVOLUME_PATH}" ]] ; then
  err "missing subvolume path; please provide parameter -s"
fi

# ----------------
# Setting constants
# ----------------

readonly BACKUP_ROOT

# Name of the subvolume that contains all snapshots
readonly SNAPSHOT_SUBVOL_NAME="${SNAPSHOT_SUBVOL_NAME:-.snapshots}"

# Prefix used for individual snapshots and backup directories
readonly PREFIX="${PREFIX:-$(basename "${SUBVOLUME_PATH}")}-"

# Timestamp used in snapshot and backup names
readonly TIMESTAMP="$(date +%Y%m%d-%H%M%S%z)"

# Full name prefix for snapshots
readonly SNAP_PREFIX="${PREFIX}snapshot-"

# Full name prefix for backups
readonly BACKUP_PREFIX="${PREFIX}backup-"


readonly SNAPSHOT_SUBVOL="${SUBVOLUME_PATH}/${SNAPSHOT_SUBVOL_NAME}"

readonly NEW_SNAPSHOT="${SNAPSHOT_SUBVOL}/${SNAP_PREFIX}${TIMESTAMP}"
readonly LAST_SNAPSHOT="$(ls -1dr ${SNAPSHOT_SUBVOL}/${SNAP_PREFIX}* | head -1 )"

readonly MAX_FILE_SIZE="${MAX_FILE_SIZE:-0}"

readonly MODE="${MODE:-backup}"

# ----------------
# Helper functions
# ----------------

readonly BTRFS="$(which btrfs)"
if [[ -z "${BTRFS}" ]] ; then
  err "can't find btrfs command"
fi

# checks if a given path points to a btrfs subvolume
function is_subvolume() {
  local vol_dir="$1"
  "${BTRFS}" subvolume show "${vol_dir}" >> /dev/null 2>&1
}

# creates a btrfs subvolume at a given path
function create_subvolume() {
  local sub_vol="$1"
  mkdir -p "$(dirname ${sub_vol})"
  if ! "${BTRFS}" subvolume create "${sub_vol}" ; then
    err "failed to create subvolume \"${sub_vol}\""
  fi  
}

# returns the generation number for a given snapshot/subvolume
function snapshot_generation() {
  local snap="$1"
  "${BTRFS}" subvolume show "${snap}" | grep "Generation" | awk '{ print $2 }' 
}

# returns the list of files in a given snapshot that have been changes since a given generation.
function snapshot_changed_files() {
  local snap="$1"
  local generation="${2:-0}"
  "${BTRFS}" subvolume find-new "${snap}" "${generation}" | awk '{ print $17 }' | sort | uniq
}

# reads stdin, compresses it and finally splits the result into individual files with a max size
function compress_and_split() {
  local dest="$1"
  local size="${2:-${MAX_FILE_SIZE}}"
  if [[ "${size}" == "0" ]] ; then
    gzip --fast --stdout > "${dest}.gz"
  else 
    gzip --fast --stdout | split -b "${size}" -a 5 - "${dest}.gz."
  fi
}

function backup_status_file(){
  local backup_dir="$1"
  if [[ -n "${backup_dir}" ]] ; then
    echo "${1}.status"
  else
    echo "/dev/null"
  fi
}

function set_backup_status(){
  local backup_dir="$1"
  local status="$2"
  echo "${status}" > "$(backup_status_file "${backup_dir}")"
  sync
}

function get_backup_status(){
  local backup_dir="$1"
  cat "$(backup_status_file "${backup_dir}")" 2>/dev/null || echo ""
}

function clear_backup_status(){
  local backup_dir="$1"
  if [[ -n "${backup_dir}" ]] ; then
    rm -f "$(backup_status_file "${backup_dir}")"
    sync
  fi
}

function find_pending_backups(){
  local backup_root="$1"
  ls -1 "${backup_root}/"*.status 2>/dev/null | sed -e "s/\\.status\$//g"
}

# prepares a new backup by creating the directory and setting some global variables
function prepare_backup(){
  # only backup when backup destination is provided
  if [[ -z "${BACKUP_ROOT}" ]] ; then
    readonly BACKUP_MODE="none"
    readonly BACKUP_DIR=""
  else 
    # create backup directory if missing
    if [[ ! -d "${BACKUP_ROOT}" ]] && ! mkdir -p "${BACKUP_ROOT}" ; then
      err "could not create directory for backups"
    fi

    if [[ "${FORCE_FULL_BACKUP}" != true && -d "${LAST_SNAPSHOT}" ]]; then
      readonly BACKUP_MODE="incr"
    else
      readonly BACKUP_MODE="full"
    fi

    readonly BACKUP_DIR="${BACKUP_ROOT}/${BACKUP_PREFIX}${TIMESTAMP}-${BACKUP_MODE}"
    mkdir -p "${BACKUP_DIR}"
  fi
}

function create_readonly_snapshot(){
  local subvolume="$1"
  local snapshot="$2"
  local backup_dir="$3"
  
  set_backup_status "${backup_dir}" "snapshot"
  
  # create the new readonly snapshot
  if ! "${BTRFS}" subvolume snapshot -r "${subvolume}" "${snapshot}" >> /dev/null 2>&1 ; then
    clear_backup_status "${backup_dir}"
    err "failed to create new readonly snapshot \"${snapshot}\" for \"${subvolume}\""
  fi
  sync
}

function backup_snapshot(){
  local mode="$1"
  local snapshot="$2"
  local backup_dir="$3"
  local last_snapshot="$4"

  set_backup_status "${backup_dir}" "backup"
  
  # create either full or incremental backup archive 
  if [[ "${mode}" == "full" ]]; then
    snapshot_changed_files "${snapshot}" "$(snapshot_generation "${last_snapshot}")" > "${backup_dir}/files.txt"
    "${BTRFS}" send -p "${last_snapshot}" "${snapshot}" | compress_and_split "${backup_dir}/stream.btrfs"
  else
    snapshot_changed_files "${snapshot}" > "${backup_dir}/files.txt"
    "${BTRFS}" send "${snapshot}" | compress_and_split "${backup_dir}/stream.btrfs"
  fi
}

function rclone_backup(){
  local backup_dir="$1"
  local verbose="$2"
  local config="$3"
  
  rclone copy "${backup_dir}" "${RCLONE_REMOTE}:/$(basename "${backup_dir}")" --checksum ${verbose} ${config}
  
  local exit_code=$?
  # in case the auth token got refreshed, let's ensure that we write the new config back
  if [[ -n "${RCLONE_CONFIG_ORIG}" ]] && diff -q "${RCLONE_CONFIG_ORIG}" "${RCLONE_CONFIG}"; then
    cat "${RCLONE_CONFIG}" >"${RCLONE_CONFIG_ORIG}"
  fi
  
  return ${exit_code}
}

function transfer_backup(){
  local backup_dir="$1"
  
  set_backup_status "${backup_dir}" "transfer"

  if [[ "${DEBUG}" == "true" ]] ; then
    local verbose="-v"
  fi
  if [[ -n "${RCLONE_CONFIG}" ]]; then
    local config="--config ${RCLONE_CONFIG}"
  fi
  
  local delay=1
  while ! rclone_backup "${backup_dir}" "${verbose}" "${config}" ; do
    if [[ "${delay}" -gt 1440 ]]; then
      err "Failed to upload backup for more than 24hrs; aborting"
    fi
    sleep "${delay}m"
    delay=$((delay * 2))
  done

}

# ----------------
# main program
# ----------------

# check that the directory we try to backup is a btrfs subvolume
if ! is_subvolume "${SUBVOLUME_PATH}" ; then
  err "given path \"${SUBVOLUME_PATH}\" is not a btrfs subvolume"
fi

# ensure that we have a subvolume for the snapshots
if [[ ! -d "${SNAPSHOT_SUBVOL}" ]]; then
  create_subvolume "${SNAPSHOT_SUBVOL}"
fi

case "${MODE}" in 
  backup)
    prepare_backup

    create_readonly_snapshot "${SUBVOLUME_PATH}" "${NEW_SNAPSHOT}" "${BACKUP_DIR}"

    if [[ "${BACKUP_MODE}" != "none" ]] ; then

      backup_snapshot "${BACKUP_MODE}" "${NEW_SNAPSHOT}" "${BACKUP_DIR}" "${LAST_SNAPSHOT}"

      # upload to remove storage if rclone remote is specified
      if [[ -n "${RCLONE_REMOTE}" ]] ; then
        transfer_backup "${BACKUP_DIR}"
      fi

    fi

    clear_backup_status "${BACKUP_DIR}"
    ;;
  resume)
    for backup in $(find_pending_backups "${BACKUP_ROOT}"); do
      case "$(get_backup_status "${backup}")" in
        snapshot)
          ;;
        backup)
          local mode="sdf"
          ;;
        transfer)
          transfer_backup "${backup}"
          ;;
      esac
    done
    ;;
esac
